<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trial 1 of RGB Color Space</title>
</head>

<body>

<!--//bring in all the scripts that I need -->
<script src="js/three.min.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script> <!-- //Orbiting around scene -->
<!--<script src="js/THREEx.KeyboardState.js"></script>--> <!--Currently Not Needed. -->
<!--<script src="js/THREEx.FullScreen.js"></script> --> <!--Intially out. Makes working with FS easier. -->
<script src="js/THREEx.WindowResize.js"></script> <!--Makes window resizing better. -->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

<script>

    //General Global Variables
    var container, scene, camera, tenderer, controls, stats;
    var clock = new THREE.Clock();

    //Custom Global variables
    var cube;

    init();
    animate();

    //FUNCTIONS
    function init() { //These things need to be initialized prior to any movement of the webpage

        scene = new THREE.Scene(); //Creates a new scene

        var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight; //declares screen height and width
        var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000; //Sets view angle, aspect ratio, camera distance
        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR); //Declares camera = new three object camera using above var
        scene.add(camera);
        camera.position.set(0, 150, 400); //Set Camera position to 0x, 150y, 400x
        camera.lookAt(scene.position); //when init, camera look at position of the scene

        //RENDERER
        if (Detector.webgl) {
            renderer = new THREE.WebGLRenderer({antialias: true});
        } else {
            renderer = new THREE.CanvasRenderer();
        }
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        container = document.getElementById('ThreeJS');
        container.appendChild(renderer.domElement);

        //CONTROLS
        //controls = new THREE.OrbitControls(camera, renderer.domElement); //Makes control object calling the OrbitControls Method

        //STATS (This is just general code. Was copied)
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.bottom = '0px';
        stats.domElement.style.zIndex = 100;
        container.appendChild(stats.domElement);

        //LIGHT
        var light = new THREE.PointLight(0xffffff);
        light.position.set(0, 250, 0);
        scene.add(light); //Add the new point light to the scene

        // this material causes a mesh to use colors assigned to vertices
        //   different colors at face vertices create gradient effect
        var cubeMaterial = new THREE.MeshBasicMaterial(
            {color: 0xffffff, vertexColors: THREE.VertexColors});

        var color, face, numberOfSides, vertexIndex;


        //////////////////////////////////////////////////////////////////////

        var faceIndices = ['a', 'b', 'c', 'd'];

        // RGB color cube
        var size = 80;
        var point;
        var cubeGeometry = new THREE.CubeGeometry(size, size, size, 1, 1, 1);
        for (var i = 0; i < cubeGeometry.faces.length; i++) {
            face = cubeGeometry.faces[i];
            // determine if current face is a tri or a quad
            numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
            // assign color to each vertex of current face
            for (var j = 0; j < numberOfSides; j++) {
                vertexIndex = face[faceIndices[j]];
                // store coordinates of vertex
                point = cubeGeometry.vertices[vertexIndex];
                // initialize color variable
                color = new THREE.Color(0xffffff);
                color.setRGB(0.5 + point.x / size, 0.5 + point.y / size, 0.5 + point.z / size);
                face.vertexColors[j] = color;
            }
        }

        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(100, 50, 0);
        scene.add(cube);
    }

        function rotateCube() {
            cube.rotation.x -= 0.005 * 2;
            cube.rotation.y -= 0.005;
            cube.rotation.z -= 0.005 * 3;
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }


        function render() {
            renderer.render(scene, camera);
            rotateCube()

        }

</script>

</body>
</html>